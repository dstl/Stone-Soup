import numpy as np
from typing import MutableSequence

from ..base import Property
from ..types.state import State, StateVector
from ..sensormanager.action import ActionableProperty
from ..movable.movable import MovingMovable
from ..functions import cart2pol, cart2sphere
from .action.jerk_action import JerkActionGenerator


class JerkTransitionMovable(MovingMovable):
    """An actionable movement controller where the list of `states` is
    an :class:`~.ActionableProperty`. The state at the next timestep is generated by the
    :class:`~.JerkActionGenerator`."""

    states: MutableSequence[State] = ActionableProperty(
        doc='Jerk transition actions',
        generator_cls=JerkActionGenerator,
        generator_kwargs_mapping={'constraints': 'constraints',
                                  'position_mapping': 'position_mapping',
                                  'velocity_mapping': 'velocity_mapping',
                                  'state': 'state'})
    constraints: tuple = Property(doc="Maximum speed and acceleration")
    orientation: StateVector = Property(doc="Initial orientation of the platform"
                                            "(default is 0)",
                                        default=None)
    transition_model = None

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        if self.transition_model:
            self.transition_model = None
        if self.orientation is None:
            self.orientation = StateVector([[0], [0], [0]])

    @orientation.getter
    def orientation(self) -> StateVector:
        """Return the orientation of the platform.

        This is defined as a 3x1 StateVector of angles (rad), specifying the sensor orientation in
        terms of the counter-clockwise rotation around each Cartesian axis in the order
        :math:`x,y,z`. The rotation angles are positive if the rotation is in the counter-clockwise
        direction when viewed by an observer looking along the respective rotation axis,
        towards the origin.

        The orientation of this platform is defined as along the direction of its velocity, with
        roll always set to zero (as this is the angle the platform is rotated about the velocity
        axis, which is not defined in this approximation).

        Notes
        -----
        Where the velocity of the platform is small, the orientation is calculated based
        on the direction it travelled from its previous position.

        Where the platform has only moved a small distance, and for a non-moving platform
        (``self.is_moving == False``) the orientation from the previous
        time step is used.
        """

        # For low velocity platforms, calculate orientation based on previous position
        if len(self) >= 2 and np.linalg.norm(self.velocity) < 1e-6 and 2 <= self.ndim <= 3:
            c_pos = self.position
            p_pos = self[-2].state_vector[self.position_mapping, ]
            # If change in position is very small, return previous orientation
            if np.linalg.norm(c_pos - p_pos) < 1e-6:
                return self._property_orientation
            if self.ndim == 2:
                _, bearing = cart2pol(*(c_pos - p_pos))
                elevation = 0
            else:
                _, bearing, elevation = cart2sphere(*(c_pos - p_pos))
            self._property_orientation = StateVector([0, elevation, bearing])

        # If platform is moving, calculate orientation from velocity information
        elif self.is_moving:
           self._property_orientation = MovingMovable.orientation.fget(self)

        return self._property_orientation

    def move(self, *args, **kwargs):
        return super().act(*args, **kwargs)
